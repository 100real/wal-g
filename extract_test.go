package extract_test

import (
	"bytes"
	"fmt"
	"github.com/katie31/extract"
	"io"
	"io/ioutil"
	"testing"
)

func testRoundTrip(t *testing.T, stride, nBytes int) {
	// Generate and save random bytes compare against compression-decompression cycle.
	sb := extract.NewStrideByteReader(stride)
	lr := &io.LimitedReader{sb, int64(nBytes)}
	b, err := ioutil.ReadAll(lr)

	// Copy generated bytes to another slice to make the test more robust against modifications of "b".
	bCopy := make([]byte, len(b))
	copy(bCopy, b)
	if err != nil {
		t.Fatal()
	}

	// Compress bytes and make a tar in memory.
	tarR, memberW := io.Pipe()
	go func() {
		extract.CreateTar(memberW, &io.LimitedReader{bytes.NewBuffer(b), int64(len(b))})
		memberW.Close()
	}()
	comReader := &extract.LzopReader{Uncompressed: tarR}
	lzopTarReader := bytes.NewBufferString(extract.LzopPrefix)
	_, err = io.Copy(lzopTarReader, comReader)
	lzopTarReader.Write(make([]byte, 12))
	if err != nil {
		t.Fatal()
	}

	// Extract the generated tar and check that its one member is the same as the bytes generated to begin with.
	brm := &BufferReaderMaker{lzopTarReader}
	buf := &extract.BufferTarInterpreter{}
	files := []extract.ReaderMaker{brm}
	extract.ExtractAll(buf, files)

	if !bytes.Equal(bCopy, buf.Out) {
		t.Fail()
	}
}

func TestUncompressableBytes(t *testing.T) {
	testRoundTrip(t, extract.LzopBlockSize*2, extract.LzopBlockSize*2)
}

func Test1Byte(t *testing.T) { testRoundTrip(t, 7924, 1) }

func Test1MByte(t *testing.T) { testRoundTrip(t, 7924, 1024*1024) }

func Test10BByte(t *testing.T) { testRoundTrip(t, 7924, 1024*1024*10) }

type BufferReaderMaker struct {
	Buf *bytes.Buffer
}

func (b *BufferReaderMaker) Reader() io.ReadCloser {
	return ioutil.NopCloser(b.Buf)
}

func setupRand(stride, nBytes int) *BufferReaderMaker {
	sb := extract.NewStrideByteReader(stride)
	lr := &io.LimitedReader{sb, int64(nBytes)}
	b := &BufferReaderMaker{bytes.NewBufferString(extract.LzopPrefix)}

	pr, pw := io.Pipe()

	go func() {
		extract.CreateTar(pw, lr)
		defer pw.Close()
	}()

	comReader := extract.LzopReader{Uncompressed: pr}
	io.Copy(b.Buf, &comReader)
	n, err := b.Buf.Write(make([]byte, 12))

	if n != 12 {
		panic("Did not write empty signal bytes. ")
	}

	if err != nil {
		panic(err)
	}

	return b
}

func BenchmarkExtractAll(b *testing.B) {
	b.SetBytes(int64(b.N * 1024 * 1024))
	out := make([]extract.ReaderMaker, 1)
	rand := setupRand(7924, b.N*1024*1024)
	fmt.Println("B.N", b.N)

	out[0] = rand

	b.ResetTimer()

	// f := &extract.FileTarInterpreter{
	// 		NewDir: "",
	// 	}
	// out[0] = f

	// extract.ExtractAll(f, out)

	// np := &extract.NOPTarInterpreter{}
	// extract.ExtractAll(np, out)

	buf := &extract.BufferTarInterpreter{}
	extract.ExtractAll(buf, out)

}
