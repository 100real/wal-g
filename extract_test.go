package walg_test

import (
	"bytes"
	"fmt"
	"github.com/katie31/wal-g"
	"github.com/katie31/wal-g/prototype"
	"io"
	"io/ioutil"
	"testing"
)

func testLzopRoundTrip(t *testing.T, stride, nBytes int) {
	/*** Generate and save random bytes compare against compression-decompression cycle. ***/
	sb := prototype.NewStrideByteReader(stride)
	lr := &io.LimitedReader{sb, int64(nBytes)}
	b, err := ioutil.ReadAll(lr)

	/*** Copy generated bytes to another slice to make the test more robust against modifications of "b". ***/
	bCopy := make([]byte, len(b))
	copy(bCopy, b)
	if err != nil {
		t.Fatal()
	}

	/*** Compress bytes and make a tar in memory. ***/
	tarR, memberW := io.Pipe()
	go func() {
		prototype.CreateTar(memberW, &io.LimitedReader{bytes.NewBuffer(b), int64(len(b))})
		memberW.Close()
	}()
	comReader := &prototype.LzopReader{Uncompressed: tarR}
	lzopTarReader := bytes.NewBufferString(prototype.LzopPrefix)
	_, err = io.Copy(lzopTarReader, comReader)
	lzopTarReader.Write(make([]byte, 12))
	if err != nil {
		t.Fatal(err)
	}

	/*** Extract the generated tar and check that its one member is the same as the bytes generated to begin with. ***/
	brm := &BufferReaderMaker{lzopTarReader, "lzo"}
	buf := &walg.BufferTarInterpreter{}
	files := []walg.ReaderMaker{brm}
	walg.ExtractAll(buf, files)

	if !bytes.Equal(bCopy, buf.Out) {
		t.Error("decompressed output does not match input.")
	}
}

func TestLzopUncompressableBytes(t *testing.T) {
	testLzopRoundTrip(t, prototype.LzopBlockSize*2, prototype.LzopBlockSize*2)
}

func TestLzop1Byte(t *testing.T)   { testLzopRoundTrip(t, 7924, 1) }
func TestLzop1MByte(t *testing.T)  { testLzopRoundTrip(t, 7924, 1024*1024) }
func TestLzop10MByte(t *testing.T) { testLzopRoundTrip(t, 7924, 10*1024*1024) }

type BufferReaderMaker struct {
	Buf        *bytes.Buffer
	FileFormat string
}

func (b *BufferReaderMaker) Reader() io.ReadCloser {
	return ioutil.NopCloser(b.Buf)
}

func (b *BufferReaderMaker) Format() string {
	return b.FileFormat
}

func setupRand(stride, nBytes int) *BufferReaderMaker {
	sb := prototype.NewStrideByteReader(stride)
	lr := &io.LimitedReader{sb, int64(nBytes)}
	b := &BufferReaderMaker{bytes.NewBufferString(prototype.LzopPrefix), "lzo"}

	pr, pw := io.Pipe()

	go func() {
		prototype.CreateTar(pw, lr)
		defer pw.Close()
	}()

	comReader := prototype.LzopReader{Uncompressed: pr}
	io.Copy(b.Buf, &comReader)
	n, err := b.Buf.Write(make([]byte, 12))

	if n != 12 {
		panic("Did not write empty signal bytes. ")
	}

	if err != nil {
		panic(err)
	}

	return b
}

func BenchmarkExtractAll(b *testing.B) {
	b.SetBytes(int64(b.N * 1024 * 1024))
	out := make([]walg.ReaderMaker, 1)
	rand := setupRand(7924, b.N*1024*1024)
	fmt.Println("B.N", b.N)

	out[0] = rand

	b.ResetTimer()

	// f := &extract.FileTarInterpreter{
	// 		NewDir: "",
	// 	}
	// out[0] = f

	// extract.ExtractAll(f, out)

	// np := &extract.NOPTarInterpreter{}
	// extract.ExtractAll(np, out)

	buf := &walg.BufferTarInterpreter{}
	walg.ExtractAll(buf, out)

}
