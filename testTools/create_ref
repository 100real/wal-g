package write

import (
	"archive/tar"
	"errors"
	"fmt"
	//"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var (
	TarBallDone = errors.New("Tar size capacity reached.")
	NoTarFiles  = errors.New("Did not accumulate files to bundle.")
)

type TarMember struct {
	Path string
	Info os.FileInfo
}

type TarBall struct {
	Name    string
	Size    int64
	MaxSize int64
	Files   []TarMember
	Bundle  *TarBundle
}

type TarBundle struct {
	Members map[string]os.FileInfo
	BaseDir string
}

func partitionFiles(tb *TarBall) {
	
	// _, ok := tb.Bundle.Members[info.Name()]

	// if tb.Size > tb.MaxSize {
	// 	return TarBallDone
	// }

	// if tb.Bundle.Running >= tb.Bundle.Total {
	// 	fmt.Println("RUNNING:", tb.Bundle.Running)
	// 	fmt.Println("TOTAL:", tb.Bundle.Total)
	// 	return io.EOF
	// }

	// if !ok {
	// 	tb.Files = append(tb.Files, t)

	// 	tb.Size = tb.Size + info.Size()
	// 	tb.Bundle.Running = tb.Bundle.Running + info.Size()
	// }
}

func getFiles(bundle *TarBundle) filepath.WalkFunc {
	return func(path string, info os.FileInfo, err error) error {
		if err != nil {
			panic(err)
		}

		
		return nil
	}
}

func MakeOneTar(tb *TarBall, trim string) error {
	f, err := os.Create(tb.Name)
	if err != nil {
		panic(err)
	}
	tw := tar.NewWriter(f)

	if len(tb.Files) == 0 {
		return NoTarFiles
	}

	baseDir := filepath.Base(tb.Files[0].Path)
	var trim string
	for i, val := range tb.Files {
		fmt.Println(val.Info.Name())

		hdr, err := tar.FileInfoHeader(val.Info, val.Info.Name())
		if err != nil {
			panic(err)
		}

		hdr.Name = filepath.Join(baseDir, strings.TrimPrefix(val.Path, trim))

		err = tw.WriteHeader(hdr)
		if err != nil {
			panic(err)
		}

		if !val.Info.Mode().IsDir() {
			body, err := ioutil.ReadFile(val.Path)
			if err != nil {
				panic(err)
			}

			_, err = tw.Write(body)
			if err != nil {
				panic(err)
			}
		}
	}

	if err := tw.Close(); err != nil {
		panic(err)
	}

	f.Close()
	return nil
}

func PartitionTars(partition int, source, out string) {
	bundle := &TarBundle{
		Members: make(map[string]os.FileInfo),
	}

	err := filepath.Walk(source, getFiles(bundle))
	if err != nil {
		panic(err)
	}

	for n, v := range bundle.Members {
		fmt.Printf("NAME: %s\nVALUE: %s\n", n, v.Name())
	}

	// counter := 0
	// tb := &TarBall{
	// 	Name:    "part_" + fmt.Sprintf("%0.3d", counter),
	// 	MaxSize: int64(partition),
	// 	Bundle:  bundle,
	// 	Files:   make([]TarMember, 0),
	// }

	// for {
	// 	err = filepath.Walk(source, getFiles(bundle))
	// 	fmt.Println(tb.Files)
	// 	fmt.Println(len(tb.Files))
	// 	fmt.Println(err)
	// 	if err == io.EOF {
	// 		break
	// 	}
	// 	if err == TarBallDone {
	// 		err = MakeOneTar(tb)
	// 		if err != nil {
	// 			panic(err)
	// 		}
	// 		counter++
	// 		tb = &TarBall{
	// 			Name:    filepath.Join(out, "part_"+fmt.Sprintf("%0.3d", counter)+".tar"),
	// 			MaxSize: int64(partition),
	// 			Bundle:  bundle,
	// 			Files:   make([]TarMember, 0),
	// 		}
	// 	}
	//}

}
